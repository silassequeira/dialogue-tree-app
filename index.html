<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dialogue Tree Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid rgba(255, 255, 255, 0.1);
        }

        .main-editor {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .canvas {
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            position: relative;
            overflow: auto;
            cursor: grab;
        }

        .canvas:active {
            cursor: grabbing;
        }

        .section {
            margin-bottom: 25px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section h3 {
            margin-bottom: 10px;
            color: #64b5f6;
            font-size: 16px;
            border-bottom: 1px solid rgba(100, 181, 246, 0.3);
            padding-bottom: 5px;
        }

        .btn {
            background: linear-gradient(45deg, #42a5f5, #1976d2);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            margin: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .btn.success {
            background: linear-gradient(45deg, #66bb6a, #388e3c);
        }

        .btn.danger {
            background: linear-gradient(45deg, #ef5350, #d32f2f);
        }

        input,
        textarea,
        select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
        }

        input::placeholder,
        textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .dialogue-node {
            position: absolute;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            min-width: 250px;
            max-width: 350px;
            cursor: move;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .dialogue-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .dialogue-node.npc {
            border-color: #4caf50;
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.05));
        }

        .dialogue-node.player {
            border-color: #2196f3;
            background: linear-gradient(145deg, rgba(33, 150, 243, 0.2), rgba(33, 150, 243, 0.05));
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .node-type {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 12px;
            font-weight: bold;
        }

        .node-type.npc {
            background: #4caf50;
        }

        .node-type.player {
            background: #2196f3;
        }

        .node-content {
            margin-bottom: 10px;
        }

        .node-text {
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .node-conditions {
            font-size: 11px;
            color: #ffeb3b;
            margin-bottom: 5px;
        }

        .node-consequences {
            font-size: 11px;
            color: #ff9800;
            margin-bottom: 5px;
        }

        .connection-point {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            border: 2px solid white;
            transition: all 0.2s ease;
        }

        .connection-point:hover {
            transform: scale(1.3);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }

        .output-point {
            background: #ff5722;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .input-point {
            background: #4caf50;
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-line {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .game-elements {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }

        .element-tag {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 10px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(30, 60, 114, 0.95), rgba(42, 82, 152, 0.95));
            padding: 30px;
            border-radius: 15px;
            width: 500px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(15px);
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 6px 6px 0 0;
            margin-right: 2px;
        }

        .tab.active {
            background: rgba(255, 255, 255, 0.2);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .toolbar {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            margin: 3px 0;
            border-radius: 4px;
            font-size: 12px;
        }

        .choices-container {
            margin-top: 10px;
        }

        .choice-item {
            background: rgba(33, 150, 243, 0.2);
            padding: 8px;
            margin: 5px 0;
            border-radius: 6px;
            border-left: 3px solid #2196f3;
            font-size: 12px;
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .connection-line path {
            stroke: rgba(255, 255, 255, 0.6);
            stroke-width: 2;
            fill: none;
            filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.3));
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h3>üìù Create Dialogue</h3>
                <button class="btn" onclick="createNode('npc')">Add NPC Dialogue</button>
                <button class="btn" onclick="createNode('player')">Add Player Choice</button>
            </div>

            <div class="section">
                <h3>üéÆ Game Elements</h3>
                <div style="margin-bottom: 10px;">
                    <strong>NPCs:</strong>
                    <div id="npcList"></div>
                    <input type="text" id="newNpc" placeholder="Add NPC name">
                    <button class="btn success" onclick="addGameElement('npc')">Add NPC</button>
                </div>

                <div style="margin-bottom: 10px;">
                    <strong>Items:</strong>
                    <div id="itemList"></div>
                    <input type="text" id="newItem" placeholder="Add item name">
                    <button class="btn success" onclick="addGameElement('item')">Add Item</button>
                </div>

                <div>
                    <strong>Locations:</strong>
                    <div id="locationList"></div>
                    <input type="text" id="newLocation" placeholder="Add location name">
                    <button class="btn success" onclick="addGameElement('location')">Add Location</button>
                </div>
            </div>

            <div class="section">
                <h3>üíæ Export/Import</h3>
                <button class="btn success" onclick="exportData()">Export JSON</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData()">
                <button class="btn" onclick="document.getElementById('importFile').click()">Import JSON</button>
                <button class="btn danger" onclick="clearAll()">Clear All</button>
            </div>
        </div>

        <div class="main-editor">
            <div class="toolbar">
                <button class="btn" onclick="zoomIn()">üîç+</button>
                <button class="btn" onclick="zoomOut()">üîç-</button>
                <button class="btn" onclick="resetZoom()">Reset Zoom</button>
            </div>

            <div class="canvas" id="canvas">
                <svg id="connectionSvg"></svg>
            </div>
        </div>
    </div>

    <!-- Node Edit Modal -->
    <div id="nodeModal" class="modal">
        <div class="modal-content">
            <div class="tabs">
                <button class="tab active" onclick="switchTab(this, 'content-tab')">Content</button>
                <button class="tab" onclick="switchTab(this, 'conditions-tab')">Conditions</button>
                <button class="tab" onclick="switchTab(this, 'consequences-tab')">Actions</button>
            </div>

            <div id="content-tab" class="tab-content active">
                <h3>Dialogue Content</h3>
                <textarea id="nodeText" rows="4" placeholder="Enter dialogue text..."></textarea>

                <div id="choicesSection" style="display: none;">
                    <h4>Player Choices:</h4>
                    <div id="choicesList"></div>
                    <button class="btn success" onclick="addChoice()">Add Choice</button>
                </div>

                <h4>Associated Elements:</h4>
                <select id="associatedNpc">
                    <option value="">Select NPC (optional)</option>
                </select>
            </div>

            <div id="conditions-tab" class="tab-content">
                <h3>Conditions (When this appears)</h3>
                <div>
                    <label>Required Items:</label>
                    <div id="conditionItems"></div>
                </div>
                <div>
                    <label>Required Location:</label>
                    <select id="conditionLocation">
                        <option value="">Any location</option>
                    </select>
                </div>
                <div>
                    <label>Custom Condition:</label>
                    <input type="text" id="customCondition" placeholder="e.g., player.level >= 5">
                </div>
            </div>

            <div id="consequences-tab" class="tab-content">
                <h3>Actions (What happens after)</h3>
                <div>
                    <label>Give Items:</label>
                    <div id="giveItems"></div>
                </div>
                <div>
                    <label>Remove Items:</label>
                    <div id="removeItems"></div>
                </div>
                <div>
                    <label>Change Location To:</label>
                    <select id="changeLocation">
                        <option value="">No change</option>
                    </select>
                </div>
                <div>
                    <label>Custom Action:</label>
                    <input type="text" id="customAction" placeholder="e.g., player.experience += 100">
                </div>
            </div>

            <div style="margin-top: 20px; display: flex; gap: 10px;">
                <button class="btn success" onclick="saveNode()">Save</button>
                <button class="btn" onclick="closeModal()">Cancel</button>
                <button class="btn danger" onclick="deleteCurrentNode()">Delete Node</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let nodes = [];
        let connections = [];
        let gameElements = {
            npcs: [],
            items: [],
            locations: []
        };
        let currentNodeId = null;
        let nodeCounter = 0;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let isConnecting = false;
        let connectionStart = null;
        let zoomLevel = 1;
        let panOffset = { x: 0, y: 0 };

        // Initialize
        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('canvas');

            // Canvas panning
            let isPanning = false;
            let startPan = { x: 0, y: 0 };

            canvas.addEventListener('mousedown', function (e) {
                if (e.target === canvas) {
                    isPanning = true;
                    startPan = { x: e.clientX - panOffset.x, y: e.clientY - panOffset.y };
                }
            });

            document.addEventListener('mousemove', function (e) {
                if (isPanning) {
                    panOffset.x = e.clientX - startPan.x;
                    panOffset.y = e.clientY - startPan.y;
                    canvas.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoomLevel})`;
                }
            });

            document.addEventListener('mouseup', function () {
                isPanning = false;
            });

            // Close modal when clicking outside
            document.getElementById('nodeModal').addEventListener('click', function (e) {
                if (e.target === this) closeModal();
            });

            updateGameElementSelects();
        });

        function createNode(type) {
            const canvas = document.getElementById('canvas');
            const node = {
                id: ++nodeCounter,
                type: type,
                x: Math.random() * 400 + 100,
                y: Math.random() * 300 + 100,
                text: type === 'npc' ? 'NPC says something...' : 'Player choice...',
                choices: type === 'player' ? ['Choice 1'] : [],
                associatedNpc: '',
                conditions: {
                    requiredItems: [],
                    requiredLocation: '',
                    custom: ''
                },
                consequences: {
                    giveItems: [],
                    removeItems: [],
                    changeLocation: '',
                    custom: ''
                }
            };

            nodes.push(node);
            renderNode(node);
        }

        function renderNode(node) {
            const canvas = document.getElementById('canvas');
            const nodeElement = document.createElement('div');
            nodeElement.className = `dialogue-node ${node.type}`;
            nodeElement.style.left = node.x + 'px';
            nodeElement.style.top = node.y + 'px';
            nodeElement.dataset.nodeId = node.id;

            let choicesHtml = '';
            if (node.type === 'player' && node.choices.length > 0) {
                choicesHtml = '<div class="choices-container">';
                node.choices.forEach(choice => {
                    choicesHtml += `<div class="choice-item">${choice}</div>`;
                });
                choicesHtml += '</div>';
            }

            let conditionsHtml = '';
            if (node.conditions.requiredItems.length > 0 || node.conditions.requiredLocation || node.conditions.custom) {
                conditionsHtml = '<div class="node-conditions">Conditions: ';
                if (node.conditions.requiredItems.length > 0) conditionsHtml += `Items: ${node.conditions.requiredItems.join(', ')} `;
                if (node.conditions.requiredLocation) conditionsHtml += `Location: ${node.conditions.requiredLocation} `;
                if (node.conditions.custom) conditionsHtml += `Custom: ${node.conditions.custom}`;
                conditionsHtml += '</div>';
            }

            let consequencesHtml = '';
            if (node.consequences.giveItems.length > 0 || node.consequences.removeItems.length > 0 || node.consequences.changeLocation || node.consequences.custom) {
                consequencesHtml = '<div class="node-consequences">Actions: ';
                if (node.consequences.giveItems.length > 0) consequencesHtml += `Give: ${node.consequences.giveItems.join(', ')} `;
                if (node.consequences.removeItems.length > 0) consequencesHtml += `Remove: ${node.consequences.removeItems.join(', ')} `;
                if (node.consequences.changeLocation) consequencesHtml += `Go to: ${node.consequences.changeLocation} `;
                if (node.consequences.custom) consequencesHtml += `Custom: ${node.consequences.custom}`;
                consequencesHtml += '</div>';
            }

            nodeElement.innerHTML = `
                <div class="node-header">
                    <span class="node-type ${node.type}">${node.type.toUpperCase()}</span>
                    <button class="btn" onclick="editNode(${node.id})" style="padding: 5px 8px; font-size: 11px;">Edit</button>
                </div>
                <div class="node-content">
                    <div class="node-text">${node.text}</div>
                    ${conditionsHtml}
                    ${consequencesHtml}
                    ${node.associatedNpc ? `<div class="element-tag">NPC: ${node.associatedNpc}</div>` : ''}
                    ${choicesHtml}
                </div>
                <div class="connection-point input-point" onclick="startConnection(${node.id}, 'input')"></div>
                <div class="connection-point output-point" onclick="startConnection(${node.id}, 'output')"></div>
            `;

            // Make draggable
            makeNodeDraggable(nodeElement, node);

            canvas.appendChild(nodeElement);
        }

        function makeNodeDraggable(element, node) {
            let isDragging = false;
            let offset = { x: 0, y: 0 };

            element.addEventListener('mousedown', function (e) {
                if (e.target.classList.contains('connection-point') || e.target.tagName === 'BUTTON') return;

                isDragging = true;
                const rect = element.getBoundingClientRect();
                offset.x = e.clientX - rect.left;
                offset.y = e.clientY - rect.top;
                element.style.zIndex = 1000;
            });

            document.addEventListener('mousemove', function (e) {
                if (!isDragging) return;

                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                node.x = e.clientX - canvasRect.left - offset.x;
                node.y = e.clientY - canvasRect.top - offset.y;

                element.style.left = node.x + 'px';
                element.style.top = node.y + 'px';

                updateConnections();
            });

            document.addEventListener('mouseup', function () {
                if (isDragging) {
                    isDragging = false;
                    element.style.zIndex = '';
                }
            });
        }

        function startConnection(nodeId, type) {
            if (!isConnecting) {
                isConnecting = true;
                connectionStart = { nodeId, type };
                console.log('Started connection from', nodeId, type);
            } else {
                // Complete connection
                if (connectionStart.nodeId !== nodeId) {
                    const connection = {
                        from: connectionStart.type === 'output' ? connectionStart.nodeId : nodeId,
                        to: connectionStart.type === 'output' ? nodeId : connectionStart.nodeId
                    };
                    connections.push(connection);
                    updateConnections();
                }
                isConnecting = false;
                connectionStart = null;
            }
        }

        function updateConnections() {
            const svg = document.getElementById('connectionSvg');
            svg.innerHTML = '';

            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);

                if (fromNode && toNode) {
                    // Create arrow
                    const fromX = fromNode.x + 250; // Right edge of fromNode
                    const fromY = fromNode.y + 125;  // Middle of fromNode
                    const toX = toNode.x;           // Left edge of toNode
                    const toY = toNode.y + 60;      // Middle of toNode

                    // Create line element
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', fromX);
                    line.setAttribute('y1', fromY);
                    line.setAttribute('x2', toX);
                    line.setAttribute('y2', toY);
                    line.setAttribute('stroke', 'rgba(255, 255, 255, 0.6)');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                    svg.appendChild(line);
                }
            });
        }

        function editNode(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            currentNodeId = nodeId;

            // Fill form
            document.getElementById('nodeText').value = node.text;

            // Show/hide choices section
            const choicesSection = document.getElementById('choicesSection');
            if (node.type === 'player') {
                choicesSection.style.display = 'block';
                renderChoicesList(node.choices);
            } else {
                choicesSection.style.display = 'none';
            }

            // Fill conditions
            updateItemCheckboxes('conditionItems', node.conditions.requiredItems, 'condition');
            document.getElementById('conditionLocation').value = node.conditions.requiredLocation;
            document.getElementById('customCondition').value = node.conditions.custom;

            // Fill consequences
            updateItemCheckboxes('giveItems', node.consequences.giveItems, 'give');
            updateItemCheckboxes('removeItems', node.consequences.removeItems, 'remove');
            document.getElementById('changeLocation').value = node.consequences.changeLocation;
            document.getElementById('customAction').value = node.consequences.custom;

            // Fill associated elements
            document.getElementById('associatedNpc').value = node.associatedNpc;

            document.getElementById('nodeModal').style.display = 'block';
        }

        function renderChoicesList(choices) {
            const container = document.getElementById('choicesList');
            container.innerHTML = '';

            choices.forEach((choice, index) => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <input type="text" value="${choice}" onchange="updateChoice(${index}, this.value)" style="width: 80%; display: inline-block;">
                    <button class="btn danger" onclick="removeChoice(${index})" style="width: 18%; display: inline-block;">Remove</button>
                `;
                container.appendChild(div);
            });
        }

        function addChoice() {
            const node = nodes.find(n => n.id === currentNodeId);
            if (node) {
                node.choices.push('New choice');
                renderChoicesList(node.choices);
            }
        }

        function updateChoice(index, value) {
            const node = nodes.find(n => n.id === currentNodeId);
            if (node) {
                node.choices[index] = value;
            }
        }

        function removeChoice(index) {
            const node = nodes.find(n => n.id === currentNodeId);
            if (node) {
                node.choices.splice(index, 1);
                renderChoicesList(node.choices);
            }
        }

        function updateItemCheckboxes(containerId, selectedItems, prefix) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            gameElements.items.forEach(item => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label style="display: flex; align-items: center; margin: 5px 0;">
                        <input type="checkbox" ${selectedItems.includes(item) ? 'checked' : ''} 
                               onchange="toggleItem('${containerId}', '${item}', this.checked)">
                        <span style="margin-left: 5px;">${item}</span>
                    </label>
                `;
                container.appendChild(div);
            });
        }

        function toggleItem(containerId, item, checked) {
            const node = nodes.find(n => n.id === currentNodeId);
            if (!node) return;

            let targetArray;
            if (containerId === 'conditionItems') targetArray = node.conditions.requiredItems;
            else if (containerId === 'giveItems') targetArray = node.consequences.giveItems;
            else if (containerId === 'removeItems') targetArray = node.consequences.removeItems;

            if (checked) {
                if (!targetArray.includes(item)) targetArray.push(item);
            } else {
                const index = targetArray.indexOf(item);
                if (index > -1) targetArray.splice(index, 1);
            }
        }

        function saveNode() {
            const node = nodes.find(n => n.id === currentNodeId);
            if (!node) return;

            node.text = document.getElementById('nodeText').value;
            node.associatedNpc = document.getElementById('associatedNpc').value;
            node.conditions.requiredLocation = document.getElementById('conditionLocation').value;
            node.conditions.custom = document.getElementById('customCondition').value;
            node.consequences.changeLocation = document.getElementById('changeLocation').value;
            node.consequences.custom = document.getElementById('customAction').value;

            // Re-render the node
            const nodeElement = document.querySelector(`[data-node-id="${currentNodeId}"]`);
            if (nodeElement) {
                nodeElement.remove();
                renderNode(node);
            }

            closeModal();
        }

        function deleteCurrentNode() {
            if (currentNodeId) {
                // Remove connections
                connections = connections.filter(c => c.from !== currentNodeId && c.to !== currentNodeId);

                // Remove node from array
                nodes = nodes.filter(n => n.id !== currentNodeId);

                // Remove node element
                const nodeElement = document.querySelector(`[data-node-id="${currentNodeId}"]`);
                if (nodeElement) nodeElement.remove();

                updateConnections();
                closeModal();
            }
        }

        function closeModal() {
            document.getElementById('nodeModal').style.display = 'none';
            currentNodeId = null;
        }

        function switchTab(button, tabId) {
            // Remove active class from all tabs and contents
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to clicked tab and corresponding content
            button.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }

        function addGameElement(type) {
            const inputId = `new${type.charAt(0).toUpperCase() + type.slice(1)}`;
            const input = document.getElementById(inputId);
            const value = input.value.trim();

            if (value && !gameElements[type + 's'].includes(value)) {
                gameElements[type + 's'].push(value);
                input.value = '';
                updateGameElementLists();
                updateGameElementSelects();
            }
        }

        function removeGameElement(type, name) {
            gameElements[type + 's'] = gameElements[type + 's'].filter(item => item !== name);
            updateGameElementLists();
            updateGameElementSelects();
        }

        function updateGameElementLists() {
            ['npc', 'item', 'location'].forEach(type => {
                const container = document.getElementById(type + 'List');
                container.innerHTML = '';

                gameElements[type + 's'].forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'list-item';
                    div.innerHTML = `
                        <span>${item}</span>
                        <button class="btn danger" style="padding: 3px 6px; font-size: 10px;" 
                                onclick="removeGameElement('${type}', '${item}')">√ó</button>
                    `;
                    container.appendChild(div);
                });
            });
        }

        function updateGameElementSelects() {
            // Update NPC select
            const npcSelect = document.getElementById('associatedNpc');
            npcSelect.innerHTML = '<option value="">Select NPC (optional)</option>';
            gameElements.npcs.forEach(npc => {
                npcSelect.innerHTML += `<option value="${npc}">${npc}</option>`;
            });

            // Update location selects
            ['conditionLocation', 'changeLocation'].forEach(selectId => {
                const select = document.getElementById(selectId);
                const currentValue = select.value;
                select.innerHTML = selectId === 'conditionLocation' ?
                    '<option value="">Any location</option>' :
                    '<option value="">No change</option>';

                gameElements.locations.forEach(location => {
                    select.innerHTML += `<option value="${location}">${location}</option>`;
                });

                select.value = currentValue;
            });
        }

        function exportData() {
            const data = {
                nodes: nodes,
                connections: connections,
                gameElements: gameElements,
                version: "1.0"
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dialogue-tree.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData() {
            const file = document.getElementById('importFile').files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Clear existing data
                    clearAll(false);

                    // Import data
                    nodes = data.nodes || [];
                    connections = data.connections || [];
                    gameElements = data.gameElements || { npcs: [], items: [], locations: [] };

                    if (nodes.length > 0) {
                        nodeCounter = Math.max(...nodes.map(n => n.id));
                    }

                    // Render imported nodes
                    nodes.forEach(node => renderNode(node));
                    updateConnections();
                    updateGameElementLists();
                    updateGameElementSelects();

                    alert('Dialogue tree imported successfully!');
                } catch (error) {
                    alert('Error importing file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function clearAll(confirm = true) {
            if (confirm && !window.confirm('Are you sure you want to clear all data?')) return;

            nodes = [];
            connections = [];
            gameElements = { npcs: [], items: [], locations: [] };
            nodeCounter = 0;

            document.getElementById('canvas').innerHTML = '<svg id="connectionSvg"></svg>';
            updateGameElementLists();
            updateGameElementSelects();
        }

        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, 3);
            updateCanvasTransform();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.3);
            updateCanvasTransform();
        }

        function resetZoom() {
            zoomLevel = 1;
            panOffset = { x: 0, y: 0 };
            updateCanvasTransform();
        }

        function updateCanvasTransform() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoomLevel})`;
        }

        // Add some sample data on load
        setTimeout(() => {
            // Add sample game elements
            gameElements.npcs.push('Village Elder', 'Merchant', 'Guard Captain');
            gameElements.items.push('Health Potion', 'Ancient Key', 'Gold Coin', 'Magic Scroll');
            gameElements.locations.push('Village Square', 'Dark Forest', 'Ancient Temple', 'Merchant Shop');

            updateGameElementLists();
            updateGameElementSelects();

            // Create sample nodes
            const npcNode = {
                id: ++nodeCounter,
                type: 'npc',
                x: 150,
                y: 100,
                text: 'Welcome to our village, traveler! I am the Village Elder.',
                choices: [],
                associatedNpc: 'Village Elder',
                conditions: { requiredItems: [], requiredLocation: '', custom: '' },
                consequences: { giveItems: [], removeItems: [], changeLocation: '', custom: '' }
            };

            const playerNode = {
                id: ++nodeCounter,
                type: 'player',
                x: 450,
                y: 100,
                text: 'What should I ask the elder?',
                choices: ['Tell me about this place', 'Do you have any quests?', 'I must go now'],
                associatedNpc: '',
                conditions: { requiredItems: [], requiredLocation: 'Village Square', custom: '' },
                consequences: { giveItems: [], removeItems: [], changeLocation: '', custom: '' }
            };

            const questNode = {
                id: ++nodeCounter,
                type: 'npc',
                x: 750,
                y: 50,
                text: 'Yes! The ancient temple needs to be cleansed. Take this key.',
                choices: [],
                associatedNpc: 'Village Elder',
                conditions: { requiredItems: [], requiredLocation: '', custom: 'player.level >= 3' },
                consequences: { giveItems: ['Ancient Key'], removeItems: [], changeLocation: '', custom: 'player.currentQuest = "temple_cleansing"' }
            };

            nodes.push(npcNode, playerNode, questNode);
            connections.push({ from: 1, to: 2 }, { from: 2, to: 3 });

            nodes.forEach(node => renderNode(node));
            updateConnections();
        }, 500);
    </script>
</body>

</html>